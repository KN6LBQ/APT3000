<html>
<head>
<script src="wav.js"></script>
<script src="dsp.js"></script>
<script src="demodulator-am.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/Chart.js/1.0.2/Chart.min.js"></script>
<title>APT-3000</title>
</head>
<body>
	<input type="file" id="fileInput"></br>
	<canvas id="myChart" width="1000" height="400"></canvas></br></br>
	<canvas id="output" width="1000" height="400"></canvas>
	<script>
		var wavFile;
		var ctx;
		var myChart;
			
		var lower = 80000;
		var range = 200;
		var numTaps = 50;
		var f32samples;
		var filteredData;
		var signalMean = 0;
		
		//drawing context
		var imageCTX = document.getElementById("output").getContext("2d");
		
		
		window.onload = function() {
			try {
			  FileReader = FileReader;
			}
			catch (e) {
			  console.log('Your browser does not support the File API');
			}
			
			var fileInput = document.getElementById('fileInput');
			var fileDisplayArea = document.getElementById('fileDisplayArea');
			ctx = document.getElementById("myChart").getContext("2d");
			
			fileInput.addEventListener('change', function(e) {
				var file = fileInput.files[0];
				//console.log(file);
				
				wavFile = new wav(file);
				wavFile.onloadend = function () {
					console.log("loaded");
					console.log(wavFile);
					
					//rectification
					for(var c = 0; c<wavFile.dataSamples.length;c++){
						wavFile.dataSamples[c] = Math.abs(wavFile.dataSamples[c]);
					}
					console.log("rectified");
					filterSamples();
				};
			});
		}
		
		function filterSamples(){
			var coeffs = getLowPassFIRCoeffs(11025,1800,numTaps);
			var filter = new FIRFilter(coeffs);
			
			//convert to Float32s
			f32samples = new Float32Array(wavFile.dataSamples.length);
			for(var i = 0; i < wavFile.dataSamples.length; i++){
				f32samples[i] = wavFile.dataSamples[i]/32768;
			}
			
			var downsampler = new Downsampler(11025,4160,coeffs);
			filteredData = downsampler.downsample(f32samples);
			console.log("downsampled to 4160Hz");
			
			normalizeData();
			updateChart();
		}
		
		function normalizeData(){
			var maxVal = 0;
			var minVal = 1;
			for(var i = 0; i < filteredData.length; i++){
				if(filteredData[i]>maxVal){
					maxVal = filteredData[i];
				}
				if(filteredData[i]<minVal){
					minVal = filteredData[i];
				}
			}
			for(var i = 0; i < filteredData.length; i++){
				filteredData[i] = (filteredData[i]-minVal)/(maxVal-minVal);
				signalMean += filteredData[i];
			}
			signalMean = signalMean / filteredData.length;
		}
		
		function convolveWithSync(){
			var sync = [-1,-1,1,1];
			var maxVal = 0;
			var maxIndex = 0;
			for(var i = 0; i < 22050; i++){
				sum = 0;
				for(var c = 0; c < 10; c++){
					sum += (filteredData[i+c]-signalMean)*sync[c%4];
				}
				if(sum>maxVal){
					maxVal = sum;
					maxIndex = i;
				}
			}
			return maxIndex;
		}
		
		function updateChart(){
			var data = {
				labels:wavFile.dataSamples.subarray(lower,lower+range),
				datasets: [
					{
						label: "1040Hz",
						fillColor: "rgba(180,180,180,0.2)",
						strokeColor: "rgba(120,120,120,1)",
						pointColor: "rgba(120,120,120,1)",
						pointStrokeColor: "#fff",
						pointHighlightFill: "#fff",
						pointHighlightStroke: "rgba(220,220,220,1)",
						data: [0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1]
					},
					{
						label: "Filtered",
						fillColor: "rgba(180,180,180,0.2)",
						strokeColor: "rgba(240,120,120,1)",
						pointColor: "rgba(240,120,120,1)",
						pointStrokeColor: "#fff",
						pointHighlightFill: "#fff",
						pointHighlightStroke: "rgba(220,220,220,1)",
						data: filteredData.subarray(lower,lower+range)
					}
				]
			};
					
			 myChart = new Chart(ctx).Line(data);
		}
		
		//starting index comes from convolution, lineCount comes from math
		//this kind of comes from https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas
		function createImage(startingIndex,lineCount){
			
				var image = imageCTX.createImageData(1040,lineCount);
			//each line
			for(var line = 0; line < lineCount; line++){
				//each column, currently only Channel A
				for(var column = 0; column < 1040; column++){
					var value = filteredData[startingIndex+line*2080+column]*256;
					//R=G=B for grayscale
					image.data[line*1040*4 + column*4]=value;
					image.data[line*1040*4 + column*4+1]=value;
					image.data[line*1040*4 + column*4+2]=value;
					//alpha = 255
					image.data[line*1040*4 + column*4+3]=255;
				}
			}
			imageCTX.putImageData(image,0,0);
		}
			
		function changeRange(dLower,dRange){
			lower += dLower;
			range += dRange;
			updateChart();
		}
		
		function setTaps(taps){
			numTaps = taps;
			filterSamples();
		}
	</script>

</body>
</html>
